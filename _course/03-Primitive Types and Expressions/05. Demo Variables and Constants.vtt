WEBVTT

00:00:01.140 --> 00:00:09.060
OK let's start by declaring a variable of type byte and call it number.

00:00:09.060 --> 00:00:11.160
Now we want to display it on the console.

00:00:11.160 --> 00:00:19.610
So as you remember from The Last Lecture we type console Daut writes line unput the variable here.

00:00:19.620 --> 00:00:25.200
Note that as I was typing console dot WriteLine my resharper plug in are magically added this using

00:00:25.200 --> 00:00:32.130
statement on the top system is a namespace and Konsole is a class that is defined in the System namespace

00:00:32.130 --> 00:00:32.760
.

00:00:32.790 --> 00:00:37.650
So in order to use the console class we need that declaration here on the top.

00:00:37.650 --> 00:00:45.000
If you're not using resharpen you have to go here and manually type using System semicolon.

00:00:45.120 --> 00:00:47.430
OK now take a look at this number here.

00:00:47.520 --> 00:00:49.160
It has a red underline.

00:00:49.500 --> 00:00:55.380
And if we put the mouse cursor here it says local variable number might not be initialized before accessing

00:00:55.380 --> 00:00:56.730
.

00:00:56.730 --> 00:01:02.280
If you remember from the slides I told you in C-sharp before you can access a variable you need to set

00:01:02.280 --> 00:01:04.160
it in it to initialize it.

00:01:04.590 --> 00:01:09.210
And that's the reason here we have the red underline we cannot display the number on the console before

00:01:09.210 --> 00:01:10.640
initializing that.

00:01:10.650 --> 00:01:15.810
So if I try to compile the application we're going to get an error to compile an application you press

00:01:15.810 --> 00:01:19.530
control shift and B.

00:01:19.880 --> 00:01:24.600
And here's the aerialist use of unassigned local variable number.

00:01:24.990 --> 00:01:30.630
We can solve this problem by initialising number like setting it to 2 for example.

00:01:30.630 --> 00:01:33.740
And you see the red underline is gone.

00:01:34.390 --> 00:01:35.340
We can compile again.

00:01:35.340 --> 00:01:38.300
Control shift B will succeed.

00:01:38.310 --> 00:01:40.040
Take a look here.

00:01:40.160 --> 00:01:40.710
OK.

00:01:40.830 --> 00:01:46.040
Now we can run the application by press and control and F 5.

00:01:46.950 --> 00:01:47.300
OK.

00:01:47.310 --> 00:01:50.550
So we got two on the console.

00:01:50.550 --> 00:01:58.620
Now let us extend this example and declare a few more variables can define an integer int count equals

00:01:58.620 --> 00:02:02.760
10 and a float float.

00:02:02.820 --> 00:02:08.520
So a total price equals twenty ninety five dollars.

00:02:08.520 --> 00:02:10.670
Now note this red underline here.

00:02:11.280 --> 00:02:12.750
Let's find out what's happening here.

00:02:12.750 --> 00:02:14.910
So I put the mouse cursor here.

00:02:15.810 --> 00:02:17.260
It says cannot convert.

00:02:17.290 --> 00:02:20.580
Source type double to target type float.

00:02:20.670 --> 00:02:26.640
If you remember from the slides I told you by default the seashore compiler traits real numbers like

00:02:26.640 --> 00:02:31.610
this one here as double where as we are declaring a float.

00:02:31.680 --> 00:02:37.980
So here we need to explicitly tell the compiler to treat this real number as a float and we can do that

00:02:38.010 --> 00:02:41.020
by appending an F at the end.

00:02:41.310 --> 00:02:43.870
So the error is gone.

00:02:43.920 --> 00:02:50.250
Mystic inner character char character A calls a.

00:02:51.240 --> 00:02:57.110
No that is are we enclose characters by a single quote like here.

00:02:57.120 --> 00:03:03.510
We can also declare a string string is not one of the primitive types and I have covered it in a separate

00:03:03.510 --> 00:03:04.850
lecture in this course.

00:03:04.860 --> 00:03:09.870
But for now let me show you how to declare a string which just type string.

00:03:10.200 --> 00:03:19.850
Give it a name first name a cause Marsh know that with strings being close them in double code.

00:03:19.950 --> 00:03:23.890
So that's one of the differences between strings and characters.

00:03:24.720 --> 00:03:27.930
And finally let's declare a bull.

00:03:28.290 --> 00:03:31.140
Bull is working a course.

00:03:31.170 --> 00:03:32.030
True.

00:03:32.670 --> 00:03:39.770
So with boules we can either set them to True or false both true and false are Keyworth as you can see

00:03:39.780 --> 00:03:43.740
they're indicated by the blue color here and they're lowercase.

00:03:43.740 --> 00:03:52.590
So everything you see here that is blue is a keyword like a static void string class namespace and all

00:03:52.590 --> 00:03:59.150
these data types here nounless display these variables on the console.

00:03:59.190 --> 00:04:04.800
So let me show you a trick.

00:04:04.800 --> 00:04:06.650
Instead of writing cancel the write line.

00:04:06.660 --> 00:04:08.820
We can do a shortcut.

00:04:08.820 --> 00:04:11.130
This is what we call a code snippet.

00:04:11.340 --> 00:04:19.180
So we type the CW that is short for console right line and then press tab and visual studio automatically

00:04:19.200 --> 00:04:22.070
converts that to cancel the right line.

00:04:22.080 --> 00:04:26.850
There are various code snippets that help you write code faster and I will try to point them out throughout

00:04:26.850 --> 00:04:28.850
this course.

00:04:29.220 --> 00:04:31.800
So let's just play count.

00:04:32.580 --> 00:04:34.400
Now another one.

00:04:35.280 --> 00:04:36.420
Total price.

00:04:36.520 --> 00:04:42.120
Not that I can't just type T.L. And here's what we call intellisense is Visual Studio.

00:04:42.180 --> 00:04:43.920
Auto completion mechanism.

00:04:44.100 --> 00:04:49.770
You don't have to type the full name of a type or a variable as long as the intellisense detects that

00:04:50.040 --> 00:04:52.400
and is highlighted here like total price.

00:04:52.410 --> 00:04:55.590
You can simply press tab and there you go.

00:04:55.590 --> 00:04:58.850
Visual studio automatically completes that for us.

00:04:59.060 --> 00:05:00.960
Let's display the character.

00:05:01.530 --> 00:05:02.340
Same here.

00:05:02.370 --> 00:05:06.350
I just press tab again.

00:05:06.360 --> 00:05:10.730
I typed only a few characters that can press tab or enter.

00:05:11.730 --> 00:05:13.980
And finally is working.

00:05:14.060 --> 00:05:17.970
We run the application by control at 5.

00:05:18.870 --> 00:05:20.640
So we got all these values on the console

00:05:23.500 --> 00:05:26.920
OK now let me show you something else in C-sharp.

00:05:26.950 --> 00:05:32.010
We have a keyword called vore which makes variable declarations easier.

00:05:32.170 --> 00:05:38.260
For example here instead of explicitly specifying the data type for each of these here I can simply

00:05:38.260 --> 00:05:46.970
type var and I let the C-sharp compiler detect that data type for this variable here.

00:05:47.530 --> 00:05:54.910
So let me replace all of this with var.

00:06:00.160 --> 00:06:06.960
OK now if you hover the mouse over the word key word we can see the underlying data type.

00:06:07.050 --> 00:06:12.890
And in this case it is system that boolean which is the dominant type which maps to C-Sharp bool keyword

00:06:12.940 --> 00:06:14.360
.

00:06:14.700 --> 00:06:18.290
I with this one that's a string.

00:06:19.360 --> 00:06:27.710
And this one is a character and this one is system that single which maps to float in.

00:06:28.600 --> 00:06:34.860
And in the case of count it's in 32 which is integer and same for number.

00:06:34.870 --> 00:06:41.210
So the tricky thing here is by default C-Sharp creates integral numbers as integer.

00:06:41.350 --> 00:06:45.100
And when you use the VAR key word it assumes that it's an integer.

00:06:45.100 --> 00:06:49.960
If you really want to go for a byte then you have to explicitly say mystified as byte here but tell

00:06:49.960 --> 00:06:52.630
you from experience it's safe to use integer.

00:06:52.630 --> 00:06:58.960
In most cases in fact if you look at the classes in the Dartmouth framework in most cases integer is

00:06:58.960 --> 00:07:03.670
the data type used for representing integral numbers.

00:07:04.410 --> 00:07:06.910
OK I reverted back.

00:07:06.930 --> 00:07:08.570
Now I show you something else.

00:07:08.590 --> 00:07:10.610
So let's take a look at this one here.

00:07:10.690 --> 00:07:17.500
So it's a char which is a character we can put the mouse cursor here and press control and then click

00:07:21.970 --> 00:07:24.950
that opens the object browser window.

00:07:24.970 --> 00:07:30.820
Take a look here is Object Browser and it's a way to look at the various classes in your project or

00:07:30.820 --> 00:07:32.370
in the top that framework.

00:07:32.410 --> 00:07:38.060
In this case because I did a control click on the char or var keyword.

00:07:38.200 --> 00:07:39.940
This is what we got here.

00:07:39.940 --> 00:07:46.690
So char is highlighted in the ogic browser on the right side you see all the members of the char type

00:07:46.710 --> 00:07:47.030
.

00:07:47.320 --> 00:07:51.210
So these purple ones are functions or methods.

00:07:51.730 --> 00:07:56.810
If you scroll down here you'll see two fields here main Valeo and max value.

00:07:56.950 --> 00:08:04.210
We'll explore them shortly and note that here is the declaration of char char is a structure we will

00:08:04.210 --> 00:08:06.310
cover as structures later in this course.

00:08:06.490 --> 00:08:10.500
And note that it's a member of System namespace.

00:08:10.750 --> 00:08:18.280
You can click system and that shows the System namespace as well as all the types defined in the System

00:08:18.280 --> 00:08:19.340
namespace.

00:08:19.420 --> 00:08:23.000
So these are part of the dominant framework.

00:08:23.200 --> 00:08:25.550
OK let's close this for now.

00:08:26.560 --> 00:08:28.520
Let's explore another example.

00:08:28.570 --> 00:08:33.060
So I'm going to get rid of all the code here we because simply press control X on each line

00:08:37.780 --> 00:08:40.430
and that deletes all these lines here.

00:08:41.110 --> 00:08:41.740
OK let's do it.

00:08:41.740 --> 00:08:42.810
Cancel the write line.

00:08:42.850 --> 00:08:50.770
So CW tab this time I pass a string here and you specify two placeholders

00:08:54.240 --> 00:09:00.530
and finally supply a couple of arguments.

00:09:03.850 --> 00:09:05.890
OK let's see what's going on here.

00:09:05.920 --> 00:09:10.080
So here what we have is called a format string.

00:09:10.390 --> 00:09:13.870
It's a kind of string that can be used as some kind of template.

00:09:14.010 --> 00:09:21.640
So at runtime what we have here indicated by curly braces and zero as the argument will be replaced

00:09:21.910 --> 00:09:24.110
by the value we pass here.

00:09:24.160 --> 00:09:32.820
So 0 represents the first argument after this format string and one represents the second argument after

00:09:32.830 --> 00:09:36.730
this format string in this case byte the next value.

00:09:36.730 --> 00:09:40.770
So let's run this application.

00:09:41.920 --> 00:09:49.830
We got 0 and 255 and that's the range that you can store in a byte.

00:09:50.560 --> 00:09:52.490
We can do the same with the float.

00:09:52.690 --> 00:09:58.180
So CW tap a format string

00:10:01.120 --> 00:10:06.830
float mean value float max value.

00:10:07.610 --> 00:10:13.640
Run the application.

00:10:13.810 --> 00:10:17.170
So this is the range we can store with a float.

00:10:17.170 --> 00:10:20.290
It's a huge number that is displayed using the scientific notation

00:10:22.120 --> 00:10:24.620
.

00:10:25.300 --> 00:10:28.410
OK now let's take a look at constants.

00:10:29.050 --> 00:10:30.740
So I get rid of these two lines here.

00:10:30.940 --> 00:10:42.730
Control X control X we define a constant with the const keyword Konst float P three point 1 4 and we

00:10:42.730 --> 00:10:45.890
have to put f at the end because it's a float.

00:10:46.180 --> 00:10:52.780
Now because we declared p as a constant here I can change it in my program so I can go here and say

00:10:52.780 --> 00:10:55.550
P it cools one.

00:10:56.920 --> 00:11:01.150
The compiler is not happy and that's why we see that red underline here.

00:11:01.240 --> 00:11:07.990
If you hover the mouse here it says read only local content cannot be used as an assignment target.

00:11:08.140 --> 00:11:13.720
It's a little weird expression to understand but basically the intention of using constants is to have

00:11:13.720 --> 00:11:15.700
some kind of safety in your program.

00:11:15.820 --> 00:11:20.530
So if there are values that should not be changed beyond your program you defined them as constants

00:11:20.530 --> 00:11:21.450
.

00:11:22.060 --> 00:11:24.980
And this way you won't accidentally modify their values