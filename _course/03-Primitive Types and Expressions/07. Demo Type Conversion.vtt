WEBVTT

00:00:01.560 --> 00:00:06.540
Okay let's say implicit type conversion in action first I declare a byte.

00:00:06.570 --> 00:00:07.300
Call it B.

00:00:07.310 --> 00:00:09.330
Answer that one.

00:00:10.110 --> 00:00:15.100
And I declare an integer and set it to be.

00:00:15.480 --> 00:00:21.030
Again to recap a byte is only one byte and an integer is four bytes.

00:00:21.030 --> 00:00:26.940
So we can copy me to I without data loss and as you see there is no compile time error here.

00:00:27.840 --> 00:00:35.460
Let's put the eye on the console so cancel that right line and we pass on here.

00:00:35.460 --> 00:00:38.010
Note that as I typed console the right line.

00:00:38.100 --> 00:00:39.810
My resharpen plug in automatically.

00:00:39.810 --> 00:00:43.690
I did this using System statement on the top again.

00:00:43.710 --> 00:00:49.770
If you don't have the sharper You need to go manually add this statement here you run the application

00:00:49.770 --> 00:00:52.670
by control on F5.

00:00:54.300 --> 00:00:58.110
So we got on the console.

00:00:58.110 --> 00:01:01.150
Now let's reverse this and see what happens.

00:01:01.170 --> 00:01:03.110
So I'm going to get rid of this code here.

00:01:03.330 --> 00:01:06.640
Control X control X control x.

00:01:06.960 --> 00:01:09.720
First I declare an integer.

00:01:09.720 --> 00:01:17.560
Set it to 1 then declare a byte and try to copy I to be.

00:01:18.000 --> 00:01:20.560
We immediately got this red underline here.

00:01:20.910 --> 00:01:27.090
If you hover the mouse here that tooltip says cannot convert source type into the target type bytes

00:01:27.090 --> 00:01:27.840
.

00:01:27.840 --> 00:01:32.160
Sometimes this error might be in a different file which is not open in visual studio here.

00:01:32.460 --> 00:01:35.160
So you may see the error when compiling the application.

00:01:35.160 --> 00:01:36.240
Let's simulate that.

00:01:36.480 --> 00:01:43.070
So I compile this application by Control shift and B which stands for build.

00:01:44.730 --> 00:01:52.920
So here is the error cannot implicitly convert type into two byte an explicit conversion exists.

00:01:52.920 --> 00:01:55.530
Are you missing a cast.

00:01:55.710 --> 00:02:00.840
So now you understand the concept of implicit versus explicit type conversion.

00:02:00.870 --> 00:02:04.350
So what we need to do here is to do a cast.

00:02:04.650 --> 00:02:08.480
So we cast an integer to a bite.

00:02:08.670 --> 00:02:14.810
In this case no data loss will happen because the value is small enough to be stored in one byte.

00:02:15.420 --> 00:02:24.910
Let's put me on the console console the right line be run the application.

00:02:26.100 --> 00:02:27.040
So everything is good.

00:02:27.350 --> 00:02:35.430
But let's see what happens if we said I to let's say thousand we cannot store the number of thousand

00:02:35.550 --> 00:02:36.520
in a byte.

00:02:36.630 --> 00:02:39.380
The maximum we can store in a byte is 255.

00:02:39.840 --> 00:02:50.070
So if you run the application now we got to 32 because some of the bits were lost and this is the reason

00:02:50.460 --> 00:02:57.420
that C-Sharp compiler knows that there is a chance for data loss and it forces you to explicitly specify

00:02:57.420 --> 00:02:58.580
the cast.

00:02:58.770 --> 00:03:04.200
Sometimes you know that despite the differences in data types there is no chance of data loss like in

00:03:04.200 --> 00:03:06.670
the last example where I was set to 1.

00:03:06.810 --> 00:03:10.320
In those cases we can safely apply a cast.

00:03:10.320 --> 00:03:13.420
OK let's take a look at non-compatible types.

00:03:13.650 --> 00:03:15.890
So let's clean up this code.

00:03:16.950 --> 00:03:23.860
I start by declaring a string is called a number and set it to 1 2 3 4.

00:03:24.240 --> 00:03:30.290
Just recapping from The Last Lecture note that here I could declare these with the very key words and

00:03:30.420 --> 00:03:33.720
C# compiler automatically detects that this is a string.

00:03:33.720 --> 00:03:36.290
So a number will be defined as a string.

00:03:36.720 --> 00:03:41.210
And we can see that by hovering the mouse here it says system that string.

00:03:42.100 --> 00:03:44.850
Now let's say we want to convert that to a number.

00:03:45.150 --> 00:03:52.380
If I declare an integer like I I cannot cast that number to an integer because they're not compatible

00:03:52.380 --> 00:03:52.860
.

00:03:52.860 --> 00:03:58.540
Let's take a look at the error cannot cast expression of type string to type int.

00:03:58.560 --> 00:04:03.320
So if you see that error that's the time when you need to use the converse class.

00:04:04.170 --> 00:04:06.310
So we type in convert dot.

00:04:06.330 --> 00:04:15.600
Take a look at this method to here to bite to char to in 16 in 32 and many other methods here.

00:04:15.660 --> 00:04:24.530
So let's convert that to an integer which is 32 and past number as an argument here.

00:04:24.530 --> 00:04:26.390
Now let's print out the eye on the con.

00:04:27.160 --> 00:04:32.110
.

00:04:32.910 --> 00:04:34.810
Run the application.

00:04:35.550 --> 00:04:37.140
So it is one two three four.

00:04:37.140 --> 00:04:38.260
All good.

00:04:38.600 --> 00:04:44.030
But let's see what happens if instead I declared this as a byte.

00:04:45.210 --> 00:04:50.850
And here we need to use convert dot to bite.

00:04:51.090 --> 00:04:58.530
And here with display being on the console a byte does not have enough storage to store the value of

00:04:58.790 --> 00:05:01.210
1234.

00:05:01.620 --> 00:05:03.300
So when we run the application now

00:05:07.970 --> 00:05:12.680
application crashed you can sell this here.

00:05:12.930 --> 00:05:18.630
And here's the exception exception is Dartmouth's frameworks error reporting mechanism.

00:05:18.620 --> 00:05:22.970
It's an advanced topic and have covered it in detail in my C-Sharp advanced course.

00:05:23.270 --> 00:05:26.920
But in this video I will briefly show you how to handle exceptions.

00:05:27.530 --> 00:05:34.370
So here it says unhandled exception the type of exception is system the overflow exception which means

00:05:34.380 --> 00:05:39.750
we try to store a value that goes too large or too small for a byte.

00:05:39.890 --> 00:05:46.740
So each exception or error as a type in this case the overflow exception and has a message value was

00:05:46.760 --> 00:05:51.670
either too large or too small for an unsigned byte.

00:05:51.830 --> 00:05:55.680
Sometimes the exception messages are friendly enough that are easy to understand.

00:05:55.910 --> 00:05:57.400
Sometimes they're a little bit tricky.

00:05:57.410 --> 00:06:02.180
And the best way to work out what is going wrong is to jump on Google and search for the error.

00:06:02.210 --> 00:06:07.420
And there's pretty much always a stack overflow page that explains that.

00:06:07.440 --> 00:06:10.370
Now let's discard that.

00:06:10.380 --> 00:06:13.080
Let's see how to handle the exception here.

00:06:13.070 --> 00:06:20.480
So the exception happened during conversion of that string to bite what we need to do here is to wrap

00:06:20.690 --> 00:06:23.660
these few statements with a try catch block.

00:06:23.730 --> 00:06:27.650
Let's see how it works.

00:06:27.750 --> 00:06:33.380
So I just typed try and press the enter and visual studio automatically generated this block for me

00:06:33.380 --> 00:06:33.720
.

00:06:33.770 --> 00:06:36.520
Again this is what we call a code snippet.

00:06:36.740 --> 00:06:38.950
Let me do this I show you one more time.

00:06:39.060 --> 00:06:46.250
So try a serious try here and they Intellisense and this icon represents a code snippet.

00:06:46.280 --> 00:06:51.460
So if I press enter or tab you automatically get this code block.

00:06:51.500 --> 00:07:00.380
So what I'm going to do now is to move this code into a try block and the catch block gets an exception

00:07:01.110 --> 00:07:03.610
by default visual studio as this throw here.

00:07:03.620 --> 00:07:05.410
Don't worry about it just delete it again.

00:07:05.410 --> 00:07:09.280
I will explain it in detail in my C-Sharp advanced course.

00:07:09.380 --> 00:07:11.340
For now let's see what's going on here.

00:07:11.370 --> 00:07:18.020
So the code that you put inside the try block will be somehow monitored and if an exception happens

00:07:19.190 --> 00:07:21.240
this block will be executed.

00:07:21.920 --> 00:07:24.520
This prevents your application from crashing.

00:07:24.530 --> 00:07:29.720
The reason our application crashed earlier was because we did not handle the exception.

00:07:29.810 --> 00:07:35.930
So if you don't handle exception the exception will be propagated to the Dartmouth runtime and the runtime

00:07:36.000 --> 00:07:40.160
mechanism is to stop your application and display the error.

00:07:40.230 --> 00:07:45.710
Here we can handle the exception and that would prevent exception from being propagated to the runtime

00:07:45.950 --> 00:07:46.290
.

00:07:46.460 --> 00:07:52.910
So instead we can display a friendly message to the user saying for example console that right line

00:07:52.960 --> 00:07:54.620
.

00:07:55.200 --> 00:08:03.440
The number could not be converted to a byte.

00:08:03.440 --> 00:08:07.120
Now let's run the application again.

00:08:08.390 --> 00:08:14.280
See we got that friendly message and application didn't crash.

00:08:14.270 --> 00:08:18.860
So what I want you to take away from this lecture is this Convery class.

00:08:18.870 --> 00:08:24.770
Works pretty well in most cases but in cases where the source type cannot be converted to the target

00:08:24.770 --> 00:08:26.730
type there is a chance for exception.

00:08:26.780 --> 00:08:32.000
And you need to be aware of that and what you need to do is to wrap this block of code with try catch

00:08:32.000 --> 00:08:32.840
.

00:08:32.850 --> 00:08:36.480
Let's take a look at one more example before we finish this lecture.

00:08:36.480 --> 00:08:43.100
Let's remove this and instead define a string.

00:08:43.250 --> 00:08:45.880
Call it as you are and set it to true.

00:08:46.400 --> 00:08:53.220
We can use the converse class to convert that value to a boolean so it will be a Cool's convert that

00:08:53.450 --> 00:08:54.710
to boolean.

00:08:55.130 --> 00:08:56.340
And we passed that SDR.

00:08:56.350 --> 00:09:05.070
Here again in this example the string and bool are not compatible and that's why we cannot use explicit

00:09:05.070 --> 00:09:06.390
casting.

00:09:06.380 --> 00:09:10.070
So here we are using the converse class.

00:09:10.170 --> 00:09:14.620
Can display be on the console.

00:09:15.740 --> 00:09:18.910
Let's run the application.

00:09:18.920 --> 00:09:23.530
So the truth string was successfully converted to a boolean value.

00:09:24.720 --> 00:09:26.700
OK that's pretty much it for this lecture.

00:09:26.880 --> 00:09:32.830
Before I finish I just need to emphasize something here that throughout this course during early lectures

00:09:33.120 --> 00:09:38.220
you may see me using some short variable names like B or SD are here.

00:09:38.270 --> 00:09:44.130
That's purely for demonstration and keeping things simple and in building real world applications.

00:09:44.120 --> 00:09:48.280
We should really avoid naming our variables a b c SDR.

00:09:48.300 --> 00:09:50.690
It's not really a good practice.

00:09:50.690 --> 00:09:56.970
The only exception is when we get two loops which you will see later in this course in four loops.

00:09:57.020 --> 00:09:59.850
We use counter variables and we call them I or J.

00:09:59.850 --> 00:10:01.840
It's a common convention.

00:10:01.860 --> 00:10:07.140
Now here we are just starting to learn C-Sharp and it's really impossible for me to demonstrate building

00:10:07.130 --> 00:10:13.050
a real world application because we're just covering the basics or alphabets.

00:10:13.080 --> 00:10:15.130
I hope you enjoyed this lecture and thank you for watching