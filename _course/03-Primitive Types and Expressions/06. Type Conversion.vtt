WEBVTT

00:00:03.760 --> 00:00:10.170
And this video I'm going to talk about various kinds of type conversion in Souchong we have implicit

00:00:10.170 --> 00:00:16.930
type conversion explicit type conversion which is also called casting and we also have conversion between

00:00:16.930 --> 00:00:19.390
non-compatible types.

00:00:19.440 --> 00:00:22.350
Here is an example of implicit type conversion.

00:00:22.590 --> 00:00:28.230
A bite as you know takes only one bite of memory and an integer takes four bytes.

00:00:28.260 --> 00:00:31.910
So we can easily copy a byte to an integer.

00:00:32.070 --> 00:00:35.510
What happens at runtime is let's take a look at this slide.

00:00:35.520 --> 00:00:39.780
So here is the binary representation of our b variable here.

00:00:39.780 --> 00:00:45.310
So one is represented as seven bits of 0 and 1 bit of one.

00:00:45.690 --> 00:00:52.440
When we copy a by to an integer what the runtime does is it prefixes that value with a bunch of zeros

00:00:52.740 --> 00:00:54.820
to fill the four bytes.

00:00:54.900 --> 00:00:56.690
So there is no data loss.

00:00:57.110 --> 00:01:03.180
In situations like that when the compiler is 100 percent sure that the types are compatible and no data

00:01:03.180 --> 00:01:04.350
loss will happen.

00:01:04.350 --> 00:01:08.580
Values can be converted to a different type implicitly.

00:01:08.580 --> 00:01:11.460
Here's another example of implicit type conversion.

00:01:11.460 --> 00:01:16.160
So we have an integer set to 1 and we copy that to a float.

00:01:16.530 --> 00:01:19.340
Again in this example no data loss will happen.

00:01:19.840 --> 00:01:21.910
Well let's take a look at this one.

00:01:22.290 --> 00:01:29.550
Here we have declared an integer and we are trying to copy that to a byte and integer is four bytes

00:01:29.550 --> 00:01:29.970
.

00:01:29.970 --> 00:01:36.240
So when we convert that to a byte three bytes out of four bytes will be gone and there is a chance for

00:01:36.240 --> 00:01:37.630
data loss.

00:01:37.630 --> 00:01:39.630
Now data lost doesn't always happen.

00:01:39.690 --> 00:01:46.590
It only happens if the value will be stored in the integer is beyond the capacity of a byte.

00:01:46.620 --> 00:01:51.840
In this example one can be stored in a byte so no data loss will happen.

00:01:51.840 --> 00:01:57.240
But if we had let's say 300 here we cannot store 300 in a byte.

00:01:57.240 --> 00:02:02.730
So as a result of that conversion they told we lost when the compiler knows that there is a chance for

00:02:02.730 --> 00:02:03.760
data loss.

00:02:03.780 --> 00:02:10.260
It doesn't allow implicit type conversion and you need to explicitly tell the compiler that you're aware

00:02:10.260 --> 00:02:13.960
of the data loss and you still want to go ahead with the conversion.

00:02:14.070 --> 00:02:20.010
In situations like that what we do is we prefix that variable with the target type.

00:02:20.010 --> 00:02:23.640
So here I'm trying to convert I to a byte.

00:02:24.030 --> 00:02:26.880
This is what we call as casting.

00:02:27.990 --> 00:02:29.400
Here's another example.

00:02:29.400 --> 00:02:32.100
So we have a float set to 1.0.

00:02:32.460 --> 00:02:35.920
And if we try to convert that to an integer the compiler would complain.

00:02:36.060 --> 00:02:38.540
I was sure that later in the coding demo.

00:02:39.180 --> 00:02:45.060
So we need to tell the compiler that we are aware of the data loss and we still want to convert F which

00:02:45.060 --> 00:02:46.680
is a float to an integer.

00:02:46.800 --> 00:02:49.680
So we cast it like here.

00:02:50.310 --> 00:02:55.010
Sometimes we are working with types that are not compatible but you still need to convert them.

00:02:55.020 --> 00:03:00.480
For example we might have a number represented as a string as you see here and we need to convert it

00:03:00.480 --> 00:03:01.710
to an integer.

00:03:01.890 --> 00:03:08.520
In situations like that because string and end are not compatible you cannot use explicit casting.

00:03:09.240 --> 00:03:12.890
So we need a different mechanism for converting a string to a number.

00:03:13.350 --> 00:03:19.170
In situations like that we need to use the convert class or use the Parse method to convert classes

00:03:19.200 --> 00:03:23.900
part of data framework and it's defined in the system namespace.

00:03:24.090 --> 00:03:29.780
It has a bunch of methods for converting various types to other types and they all start with two.

00:03:29.940 --> 00:03:35.640
In this case we're trying to convert as much as a string to an int 32 and 32.

00:03:35.730 --> 00:03:40.400
As you know is a dot Net Framework type which maps to a C-sharp integer type.

00:03:40.530 --> 00:03:48.270
Remember a byte is one byte as short is two bytes and integer is four byte long is eight bytes.

00:03:48.270 --> 00:03:51.470
You probably know that each byte has eight bits.

00:03:51.510 --> 00:03:58.350
So an integer which has 4 bytes times eight beats ends up being 32 bits.

00:03:58.380 --> 00:04:06.240
That's why it's called two in 32 and in 16 which represents 16 bits equals two short which is two bytes

00:04:06.240 --> 00:04:07.390
.

00:04:07.440 --> 00:04:12.990
We also have this parse method here all the primitive types that I explained in the last lecture like

00:04:13.050 --> 00:04:15.870
integer long float boolean.

00:04:15.990 --> 00:04:21.870
They all have this parse method and the Parse method takes a string and tries to convert that to the

00:04:21.870 --> 00:04:22.440
target type.

00:04:22.440 --> 00:04:25.410
In this case an integer.

00:04:25.470 --> 00:04:30.600
Here are some of the methods that you can find in the convert class to byte which converts the given

00:04:30.600 --> 00:04:38.430
value to a byte to in 16 to convert the given value to a short to in 32 to convert the given value to

00:04:38.430 --> 00:04:43.200
an integer and 2 in 64 to convert the given value too long.

00:04:43.640 --> 00:04:44.670
OK enough theory.

00:04:44.670 --> 00:04:47.760
Let's jump into code and see all this concept in action.